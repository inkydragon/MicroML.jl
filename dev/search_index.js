var documenterSearchIndex = {"docs":
[{"location":"#MicroML","page":"MicroML","title":"MicroML","text":"","category":"section"},{"location":"","page":"MicroML","title":"MicroML","text":"Documentation for MicroML.","category":"page"},{"location":"","page":"MicroML","title":"MicroML","text":"Modules = [MicroML]","category":"page"},{"location":"#MicroML.AbstractML","page":"MicroML","title":"MicroML.AbstractML","text":"AbstractML\n\nTop type of MicroML\n\n\n\n\n\n","category":"type"},{"location":"#MicroML.AbstractMLASTNode","page":"MicroML","title":"MicroML.AbstractMLASTNode","text":"AbstractMLASTNode <: AbstractML\n\nattribute\n\ntype      :: String   Used by the type inference algorithm.\nchildren  :: Vector   Used by passes that traverse the AST. Each concrete node class lists the sub-nodes it has as children.\n\nmethod\n\nvisit_children(n::AbstractMLASTNode, f::Function)\nshow(io::IOBuffer, n::AbstractMLASTNode)\n\n\n\n\n\n","category":"type"},{"location":"#MicroML.AbstractMLType","page":"MicroML","title":"MicroML.AbstractMLType","text":"AbstractMLType <: AbstractML\n\nattribute\n\nname :: String\n\nmethod\n\nstring(t::AbstractMLType)\nisequal\n\n\n\n\n\n","category":"type"},{"location":"#MicroML.AbstractMLVal","page":"MicroML","title":"MicroML.AbstractMLVal","text":"AbstractMLVal <: AbstractMLASTNode\n\nattribute\n\ntype      :: String\nchildren  :: Vector\nvalue     :: String\n\nmethod\n\nstring(n::AbstractMLVal)\n\n\n\n\n\n","category":"type"},{"location":"#MicroML.MLApp","page":"MicroML","title":"MicroML.MLApp","text":"Application of a function to a sequence of arguments. func is a node, args is a sequence of nodes.\n\n\n\n\n\n","category":"type"},{"location":"#MicroML.MLBool","page":"MicroML","title":"MicroML.MLBool","text":"Bool Constant\n\n\n\n\n\n","category":"type"},{"location":"#MicroML.MLId","page":"MicroML","title":"MicroML.MLId","text":"Identifier\n\n\n\n\n\n","category":"type"},{"location":"#MicroML.MLIf","page":"MicroML","title":"MicroML.MLIf","text":"if ... then ... else ... expression.\n\n\n\n\n\n","category":"type"},{"location":"#MicroML.MLInt","page":"MicroML","title":"MicroML.MLInt","text":"Int Constant\n\n\n\n\n\n","category":"type"},{"location":"#MicroML.MLLambda","page":"MicroML","title":"MicroML.MLLambda","text":"lambda [args] -> expr\n\n\n\n\n\n","category":"type"},{"location":"#MicroML.MLOp","page":"MicroML","title":"MicroML.MLOp","text":"Binary operation between expressions.\n\n\n\n\n\n","category":"type"},{"location":"#MicroML.MLToken","page":"MicroML","title":"MicroML.MLToken","text":"A simple Token structure. Contains the token type, value and position.\n\n\n\n\n\n","category":"type"},{"location":"#MicroML.MLTypeVar","page":"MicroML","title":"MicroML.MLTypeVar","text":"A type variable.\n\n\n\n\n\n","category":"type"},{"location":"#MicroML.TypeEquation","page":"MicroML","title":"MicroML.TypeEquation","text":"TypeEquation <: AbstractML\n\nA type equation between two types: left and right. original is the original AST node from which this equation was derived, for debugging.\n\n\n\n\n\n","category":"type"},{"location":"#MicroML.Compiler-Tuple{}","page":"MicroML","title":"MicroML.Compiler","text":"Compiler()\n\nA Compiler() object.\n\nProperty\n\nattribute\n\np :: Parser\nequations\nsymtab\ncode\n\nmethod\n\ncompile(source::String)\ninterpret()\n\n\n\n\n\n","category":"method"},{"location":"#MicroML.Lexer","page":"MicroML","title":"MicroML.Lexer","text":"Lexer(rules=RULES; skip_whitespace=rrue)\n\nA simple regex-based lexer/tokenizer.\n\nProperty\n\nattribute\n\nbuf :: String\npos :: Int\n\nmethod\n\nstart(buf::String)\ntoken()\ntokens()\npeek()\n\n\n\n\n\n","category":"function"},{"location":"#MicroML.Parser-Tuple{}","page":"MicroML","title":"MicroML.Parser","text":"Parser()\n\nParser for micro-ML.\n\nUsage:\n\np = Parser()\ndecl = p.parse(<some micro-ML code>)\n# decl is now an ast.Decl node\n\nProperty\n\nattribute\n\nlexer\ntoken :: MLToken\n\nmethod\n\nparse(source::String, should_terminate::Bool=True)\n\n\n\n\n\n","category":"method"},{"location":"#MicroML.apply_unifier-Tuple{MicroML.AbstractMLType, Dict}","page":"MicroML","title":"MicroML.apply_unifier","text":"apply_unifier(typ::AbstractMLType, subst::Subst) :: Subst\n\nApplies the unifier subst to typ. Returns a type where all occurrences of variables bound in subst were replaced (recursively); on failure returns None.\n\n\n\n\n\n","category":"method"},{"location":"#MicroML.assign_typenames","page":"MicroML","title":"MicroML.assign_typenames","text":"assign_typenames(node, symtab::SymTab=SymTab())\n\nAssign typenames to the given AST subtree and all its children.\n\nSymtab is the initial symbol table we can query for identifiers found throughout the subtree. All identifiers in the subtree must be bound either in symtab or in lambdas contained in the subtree. This function updates the type property on the AST nodes it visits.\n\n\n\n\n\n","category":"function"},{"location":"#MicroML.eval","page":"MicroML","title":"MicroML.eval","text":"Eval ML code.\n\n\n\n\n\n","category":"function"},{"location":"#MicroML.generate_equations","page":"MicroML","title":"MicroML.generate_equations","text":"generate_equations(node, type_equations::Vector=[])\n\nGenerate type equations from node and place them in typeequations. Prior to calling this functions, node and its children already have to be annotated with _type, by a prior call to assigntypenames.\n\n\n\n\n\n","category":"function"},{"location":"#MicroML.get_expression_type","page":"MicroML","title":"MicroML.get_expression_type","text":"get_expression_type(\n    expr, \n    subst::Subst,\n    rename_types::Bool=true\n) :: AbstractMLType\n\nFinds the type of the expression given a substitution.\n\nIf rename_types is True, renames all the type vars to be sequential characters starting from 'a', so that 't5 -> t3' will be renamed to 'a -> b'. These names are less cluttery and also facilitate testing.\n\nNote: expr should already be annotated with assign_typenames.\n\n\n\n\n\n","category":"function"},{"location":"#MicroML.occurs_check-Tuple{MicroML.AbstractMLType, MicroML.AbstractMLType, Dict}","page":"MicroML","title":"MicroML.occurs_check","text":"occurs_check(v::AbstractMLType, typ::AbstractMLType, subst::Subst) :: Bool\n\nDoes the variable v occur anywhere inside typ? Variables in typ are looked up in subst and the check is applied recursively.\n\n\n\n\n\n","category":"method"},{"location":"#MicroML.show_type_assignment-Tuple{MicroML.AbstractMLASTNode}","page":"MicroML","title":"MicroML.show_type_assignment","text":"show_type_assignment(node)\n\nShow a type assignment for the given subtree, as a table. Returns a string that shows the assigmnent.\n\n\n\n\n\n","category":"method"},{"location":"#MicroML.unify-Tuple{MicroML.AbstractMLType, MicroML.AbstractMLType, Dict}","page":"MicroML","title":"MicroML.unify","text":"unify(typ_x, typ_y, subst)\n\nUnify two types typx and typy, with initial subst. Returns a subst (map of name->Type) that unifies typx and typy, or None if they can't be unified. Pass subst={} if no subst are initially known. Note that {} means valid (but empty) subst.\n\n\n\n\n\n","category":"method"},{"location":"#MicroML.unify_equations-Tuple{Vector}","page":"MicroML","title":"MicroML.unify_equations","text":"unify_equations(eqs::Vector) :: Subst\n\nUnifies all type equations in the sequence eqs. Returns a substitution (most general unifier).\n\n\n\n\n\n","category":"method"},{"location":"#MicroML.unify_variable-Tuple{MicroML.AbstractMLType, MicroML.AbstractMLType, Dict}","page":"MicroML","title":"MicroML.unify_variable","text":"unify_variable(v::AbstractMLType, typ::AbstractMLType, subst::Subst) :: Subst\n\nUnifies variable v with type typ, using subst. Returns updated subst or None on failure.\n\n\n\n\n\n","category":"method"},{"location":"#MicroML.visit_children-Tuple{MicroML.AbstractMLASTNode, Function}","page":"MicroML","title":"MicroML.visit_children","text":"Visit all children with a function that takes a child node.\n\n\n\n\n\n","category":"method"}]
}
